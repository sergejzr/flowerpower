//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2013.08.09 at 12:38:58 PM CEST 
//

package de.l3s.flower.jaxb;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Hashtable;
import java.util.List;
import java.util.Vector;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;

/**
 * <p>
 * Java class for anonymous complex type.
 * 
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 * 
 * <pre>
 * &lt;complexType>
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element ref="{}topics"/>
 *         &lt;element ref="{}categories"/>
 *         &lt;element ref="{}connections"/>
 *         &lt;element ref="{}general"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlRootElement(name = "flower")
public class Flower {

	@XmlElement(name = "topics", required = true)
	protected Topics topics;
	@XmlElement(name = "terms", required = true)
	protected Terms terms;
	@XmlElement(name = "categories", required = true)
	protected Categories categories;
	@XmlElement(name = "connections", required = true)
	protected Connections connections;
	@XmlElement(name = "general", required = true)
	protected General general;
	@XmlElement(name = "instances", required = true)
	protected Instances instances;

	public Instances getInstances() {
		return instances;
	}
	public void setInstances(Instances instances) {
		this.instances = instances;
	}
	/**
	 * Gets the value of the topics property.
	 * 
	 * @return possible object is {@link Topics }
	 * 
	 */
	public Topics getTopics() {
		return topics;
	}

	/**
	 * Sets the value of the topics property.
	 * 
	 * @param value
	 *            allowed object is {@link Topics }
	 * 
	 */
	public void setTopics(Topics value) {
		this.topics = value;
	}

	/**
	 * Gets the value of the categories property.
	 * 
	 * @return possible object is {@link Categories }
	 * 
	 */
	public Categories getCategories() {
		return categories;
	}

	/**
	 * Sets the value of the categories property.
	 * 
	 * @param value
	 *            allowed object is {@link Categories }
	 * 
	 */
	public void setCategories(Categories value) {
		this.categories = value;
	}

	/**
	 * Gets the value of the connections property.
	 * 
	 * @return possible object is {@link Connections }
	 * 
	 */
	public Connections getConnections() {
		return connections;
	}

	/**
	 * Sets the value of the connections property.
	 * 
	 * @param value
	 *            allowed object is {@link Connections }
	 * 
	 */
	public void setConnections(Connections value) {
		this.connections = value;
	}

	/**
	 * Gets the value of the general property.
	 * 
	 * @return possible object is {@link General }
	 * 
	 */
	public General getGeneral() {
		return general;
	}

	/**
	 * Sets the value of the general property.
	 * 
	 * @param value
	 *            allowed object is {@link General }
	 * 
	 */
	public void setGeneral(General value) {
		this.general = value;
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		try {
			JAXBContext context = JAXBContext.newInstance(getClass());
			Marshaller m = context.createMarshaller();
			m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			m.marshal(this, baos);
			sb.append(baos.toString("UTF8"));
		} catch (JAXBException e) {
			e.printStackTrace();
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		return sb.toString();
	}

	public List<Category> getOrderedCategories() {
		Categories cats = getCategories();
		List<Category> tmp = new ArrayList<Category>();
		tmp.addAll(cats.getCategory());
		Collections.sort(tmp, new Comparator<Category>() {

			@Override
			public int compare(Category c1, Category c2) {
				return c1.rank.compareTo(c2.rank);
			}
		});
		return tmp;
	}

	public List<Connection> getOrderedConnections() {
		Connections cons = getConnections();

		List<Connection> tmp = new ArrayList<Connection>();
		tmp.addAll(cons.getConnection());
		Collections.sort(tmp, new Comparator<Connection>() {

			@Override
			public int compare(Connection c1, Connection c2) {
				return c1.similarity.compareTo(c2.similarity);
			}
		});
		Connection firstcat = tmp.get(0);
		
		List<Connection> ret = new ArrayList<Connection>();
		
		Integer startid = firstcat.getCat1();
		Integer curid=startid;
		do{
			Connection curcat = getConnectionByLeadingCatId(curid);
			ret.add(curcat);
			curid=curcat.getCat2();
			
		}while(curid!=startid);
		return ret;
	}

	@XmlTransient
	Hashtable<Integer, Category> catidx = null;

	public Category getCategoryById(Integer id) {
		if (catidx == null) {
			catidx = new Hashtable<Integer, Category>();
			for (Category cat : getCategories().getCategory()) {
				catidx.put(cat.getId(), cat);
			}
		}
		return catidx.get(id);
	}

	public List<TopicLink> getOrderedTopics(List<TopicLink> topic,
			boolean reverse) {

		List<TopicLink> tmp = new ArrayList<TopicLink>();
		tmp.addAll(topic);
		if (reverse) {
			Collections.sort(tmp, new Comparator<TopicLink>() {

				@Override
				public int compare(TopicLink c1, TopicLink c2) {
					return c1.score.compareTo(c2.score);
				}
			});
		} else {
			Collections.sort(tmp, new Comparator<TopicLink>() {

				@Override
				public int compare(TopicLink c1, TopicLink c2) {
					return -1 * c1.score.compareTo(c2.score);
				}
			});

		}
		return tmp;
	}

	@XmlTransient
	Hashtable<Integer, Connection> idxcon = null;

	public Connection getConnectionByLeadingCatId(Integer id) {

		if (idxcon == null) {
			idxcon = new Hashtable<Integer, Connection>();

			for (Connection con : getConnections().getConnection()) {
				idxcon.put(con.cat1, con);
			}
		}

		return idxcon.get(id);
	}

	@XmlTransient
	Hashtable<Integer, Topic> idxtopics = null;

	public Topic getTopicById(Integer tid) {

		if (idxtopics == null) {
			idxtopics = new Hashtable<Integer, Topic>();
			for (Topic t : getTopics().topic) {
				idxtopics.put(t.getTid(), t);
			}
		}
		return idxtopics.get(tid);

	}

	public String getLable(Connection con) {
		// TODO Auto-generated method stub
		return getCategoryById(con.cat1).getName() + " - "
				+ getCategoryById(con.cat2).getName();
	}

	public Terms getTerms() {
		return terms;
	}

	public void setTerms(Terms terms) {
		this.terms = terms;
	}

	public static Flower readFlower(File flowerfile) throws JAXBException {
		Flower flower = null;
		JAXBContext jaxbContext = JAXBContext.newInstance(Flower.class);
		if (flowerfile.exists()) {

			Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller();

			flower = (Flower) jaxbUnmarshaller.unmarshal(flowerfile);

		} else {
		}
		return flower;
	}
Hashtable<Integer, Term> termidx=null;
	public Term getTermById(Integer tid) {
		fillTermIdx();
		return termidx.get(tid);
	}
	private void fillTermIdx()
	{
		if(termidx==null)
		{
			termidx=new Hashtable<Integer, Term>();
			for(Term t:getTerms().getTerms())
			{
				termidx.put(t.tid, t);
			}
		}
	}
	public Term getTermByLink(TermLink tl) {
		fillTermIdx();
			return termidx.get(tl.getTid());
		}
	public void printTopicsInfo()
	{


		Flower flower =this;
		Vector<Topic> sortedtops=new Vector<Topic>();
		sortedtops.addAll(flower.getTopics().getTopic());
		Collections.sort(sortedtops, new  Comparator<Topic>() {

			@Override
			public int compare(Topic o1, Topic o2) {
				// TODO Auto-generated method stub
				return -1*(o1.getScore().compareTo(o2.getScore()));
			}
		});
		
		for(Topic t:sortedtops)
		{		
			System.out.println((t.getScore()*10000+"\t").replaceAll("\\.", ",")+t.getLable()+"\t");
		}
		
		if(true) return;
		int topk=20;
		int curidx=0;
		for(Topic t:sortedtops)
		{
			if(curidx++>topk) break;
			System.out.print(t.getScore()+"\t"+t.getLable()+"\t");
			
			
		}
		 System.out.println();
		for(int i=0;i<30;i++)
		{
			curidx=0;
			for(Topic top:sortedtops)
			{
				if(curidx++>topk) break;
				if(i<top.getTerm().size())
				{
					TermLink tl = top.getTerm().get(i); 
					Term term = flower.getTermByLink(tl);
					 System.out.print((term==null?"null":term.getValue())+"\t"+Math.round(tl.getScore())+"\t");
				
				}else{ System.out.print("\t\t");}
			}
			System.out.println();
		}
		/*
		for(Topic t:sortedtops)
		{
			System.out.print(t.getScore()+": "+t.getLable()+": ");
			for(TermLink tl:t.getTerm())
			{
				 Term term = flower.getTermByLink(tl);
				 System.out.print((term==null?"null":term.getValue())+"("+tl.getScore()+"), ");
			}
			 System.out.println();
		}*/
		
	
		

	}
	public String label(Topic t, int k)
	{
	StringBuffer sb=new StringBuffer();
	
			for(TermLink tl:t.getTerm())
			{
				if(k--==0) break;
				 Term term = getTermByLink(tl);
				 if(sb.length()>0) sb.append(" ");
				 sb.append(term.getValue().trim());	
			}
		return sb.toString();
	}
	public String label(TopicLink t, int k)
	{
		return label(getTopicById(t.getTid()),k);
	
	}
}
